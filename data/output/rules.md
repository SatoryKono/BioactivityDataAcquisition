v1. Общие принципы

1.1. Архитектура проекта должна соответствовать паттерну Ports & Adapters (Hexagonal) + DDD.
1.2. Весь новый код должен вписываться в существующие слои: domain, application, infrastructure, interfaces.
1.3. Любой новый функционал должен сопровождаться обновлённой документацией и тестами.
1.4. Все изменения, ломающие контракты (схемы, API, конфиги), должны быть задокументированы в changelog / ADR.

2. Соглашения об именовании
2.1. Базовые правила

2.1.1. Модули и переменные: snake_case.
2.1.2. Классы: PascalCase.
2.1.3. Константы: UPPER_SNAKE_CASE.
2.1.4. Приватные атрибуты/функции: префикс _.
2.1.5. Не использовать camelCase, дефисы и пробелы в идентификаторах.

2.2. Суффиксы для классов
Роль класса	Обязательный суффикс	Пример
Фабрика	*Factory	ChemblClientFactory
Клиент данных/API	*Client	ChemblDataClient
Фасад	*Facade	PipelineRunnerFacade
Реестр	*Registry	SchemaRegistry
Адаптер/транспорт	*Adapter / *Transport	HTTPTransportAdapter
Интерфейс/ABC	*Protocol / *ABC	DataClientProtocol
Конфиг/модель	*Config / *Model / *Params	PipelineConfig
Исключение	*Error	SchemaValidationError
Конкретная реализация	*Impl	ChemblDataClientHTTPImpl

Нарушение этих суффиксов для соответствующих ролей запрещено.

2.3. Префиксы для функций
Тип функции	Префикс	Пример
Чтение локальных данных	get_	get_local_config()
Сетевые запросы / I/O	fetch_	fetch_chembl_page()
Генераторы	iter_	iter_batches()
Создание объектов	create_ / build_ / make_ / default_	build_pipeline()
Регистрация	register_	register_schema()
Валидация	validate_	validate_dataframe()
Парсинг / сериализация	parse_ / serialize_	parse_response()
Обработчики событий	on_	on_pipeline_error()
Булевы проверки	is_ / has_ / can_	is_valid(), has_nulls()

Функции должны использовать соответствующие префиксы по смыслу.

2.4. Пайплайны и сущности

2.4.1. Идентификатор пайплайна: <entity>_<source> в нижнем регистре, например: activity_chembl.
2.4.2. Папки пайплайнов: src/bioetl/application/pipelines/<provider>/<entity>/.
2.4.3. Файлы этапов пайплайна должны иметь названия по стадиям: extract.py, transform.py, validate.py, export.py (или эквивалентно, но последовательно).

2.5. Тесты

2.5.1. Файлы тестов должны называться test_*.py.
2.5.2. Структура в tests/ должна зеркально повторять src/.
2.5.3. Golden-тесты рекомендуется именовать с суффиксом _golden.py.

2.6. Документация

2.6.1. Файлы документации: kebab-case (01-pipelines-overview.md).
2.6.2. Топовые файлы разделов: README.md, индекс в папке: INDEX.md.
2.6.3. ADR: docs/architecture/decisions/NNNN-title-in-kebab-case.md.
2.6.4. Названия файлов документации должны быть на английском.
2.6.5. Первый заголовок H1 в документе должен соответствовать названию файла по смыслу.

3. Структура проекта / слоёв

3.1. Код должен находиться в src/bioetl/.
3.2. Слои:

domain/ – модели предметной области, схемы, абстрактные интерфейсы.

application/ – пайплайны, use-case логика.

infrastructure/ – адаптеры API, логирование, техсервисы.

interfaces/ – CLI и прочие интерфейсы.

3.3. Документация в docs/ должна отражать структуру src/ (domain, application, pipelines, schemas и т.д.).
3.4. Любой новый модуль должен быть размещён в соответствующем слое, а не куда попало “потому что удобно”.

4. Работа с объектами и данными
4.1. Модели и схемы

4.1.1. Для каждой выходной таблицы должна существовать Pandera-схема (DataFrameSchema).
4.1.2. Схема должна задавать:

набор колонок;

типы;

порядок колонок;

nullability.

4.1.3. Перед записью любых данных на диск/в БД обязательна валидация через Pandera.
4.1.4. Изменение схемы должно рассматриваться как потенциально ломающая смена версии и документироваться.

4.2. Pydantic-модели

4.2.1. Структуры JSON-ответов API рекомендуется описывать через Pydantic-модели (*Model).
4.2.2. Вложенные структуры должны приводиться к плоскому виду, если данные идут далее в таблицу (например, сериализацией во строку).

4.3. ABC / протоколы

4.3.1. Общие контракты (клиенты, сервисы, пайплайны) должны быть оформлены как ABC/Protocol в domain.
4.3.2. Конкретные реализации (*Impl) должны реализовывать эти контракты и жить в infrastructure.
4.3.3. Предпочтительная схема: ABC → Default/Facade → Impl.
4.3.4. Ввод нового класса при дублирующемся функционале должен сопровождаться удалением/объединением старого (принцип zero-sum class count).

5. Использование библиотек

5.1. Работа с табличными данными должна выполняться через pandas.
5.2. Валидация датафреймов должна выполняться через pandera.
5.3. Конфигурации и структуры данных должны валидироваться через Pydantic.
5.4. Сетевые запросы должны идти через единый клиент (UnifiedAPIClient), а не напрямую requests.
5.5. CLI должен использовать Typer.
5.6. Структурированный вывод и форматирование логов должно выполняться средствами Rich/логера.
5.7. YAML-конфиги должны читаться через PyYAML.

6. Стиль кода и качество

6.1. Стиль:

6.1.1. Код должен соответствовать PEP8.
6.1.2. Форматирование: Black / Ruff форматтер, max line length ~100.
6.1.3. Импорты: isort-подобный порядок (stdlib → external → internal), без from x import *.

6.2. Типизация:

6.2.1. Все публичные функции и методы должны иметь аннотации типов.
6.2.2. Проект должен проходить mypy в строгом режиме; Any допускается только в крайних случаях, с явным обоснованием.

6.3. Докстринги:

6.3.1. Публичные классы/функции должны иметь docstring с описанием назначения.
6.3.2. Язык документации в коде – преимущественно английский.

6.4. Логирование:

6.4.1. Использование print() для логов/отладки запрещено.
6.4.2. Логирование должно использовать UnifiedLogger / стандартный логгер, интегрированный с Rich.
6.4.3. Логи должны быть структурированными (JSON или структура с полями).
6.4.4. В логах запрещено выводить секреты (ключи, пароли и т.п.).

6.5. Детерминизм:

6.5.1. При одинаковых входных данных и конфигурации результирующие файлы должны быть байт-в-байт идентичны.
6.5.2. Порядок строк и колонок должен быть фиксирован (сортировка, ordered=True в схемах).
6.5.3. Запись файлов должна быть атомарной: запись во временный файл → замена.
6.5.4. Для артефактов должны вычисляться контрольные суммы (для проверки целостности).

6.6. Архитектурный стиль:

6.6.1. Предпочтение композиции над наследованием.
6.6.2. Глобальное изменяемое состояние запрещено.
6.6.3. Константы и “магические строки” должны быть вынесены в именованные константы.

7. Работа с API и внешними источниками

7.1. HTTP / API:

7.1.1. Весь сетевой доступ должен проходить через UnifiedAPIClient (или аналогичный слой).
7.1.2. Клиент должен поддерживать:

retry с backoff;

timeouts;

rate limiting;

при необходимости circuit breaker.

7.1.3. Сетевой код не должен находиться в доменном слое и в пайплайнах напрямую.

7.2. Тестирование сети:

7.2.1. Юнит-тесты не должны ходить в сеть; API должно мокаться.

7.3. Файлы и прочие источники:

7.3.1. Работу с файлами следует оборачивать в утилиты с логированием и проверкой чек-сумм.
7.3.2. Обработка файловой и API-версии данных должна использовать общий пайплайн трансформации и валидации.

7.4. Секреты:

7.4.1. API-ключи и другие секреты не должны быть в коде и репозитории.
7.4.2. Секреты должны браться из переменных окружения / секрет-хранилищ.
7.4.3. При отсутствии обязательного секрета запуск должен завершаться с ошибкой (fail-fast).

8. Конфигурация и запуск

8.1. Конфигурации:

8.1.1. Все настройки должны находиться в YAML-файлах под configs/ (пайплайны, профили).
8.1.2. YAML должен мапиться на Pydantic-модели и валидироваться при запуске.
8.1.3. В конфиге запрещено хранить секреты в открытом виде; допустимы только ссылки на env (${VAR_NAME}).

8.2. Приоритеты конфигурации:

Аргументы CLI.

Переменные окружения.

YAML пайплайна.

Профиль по умолчанию.

8.3. CLI:

8.3.1. Основное управление должно происходить через CLI на Typer.
8.3.2. Команды должны быть явными: run <pipeline_id>, --config, --output, и т.д.
8.3.3. Команды должны быть детерминированными и по возможности идемпотентными.
8.3.4. Любой запуск должен иметь run_id и корректный код выхода (0 / не-0).

8.4. Fail-fast:

8.4.1. При ошибке конфигурации / недоступности сервиса приложение должно завершаться сразу, а не “пытаться как-нибудь”.

9. Тестирование и контроль качества

9.1. Покрытие тестами:

9.1.1. Критичный код должен иметь покрытие не менее ~85%.
9.1.2. Любой новый функционал должен сопровождаться тестами.

9.2. Типы тестов:

Unit-тесты: мелкие функции/классы, без реальной сети/файлов.

Интеграционные тесты: прогон пайплайнов на небольших данных.

Golden-тесты: сравнение с эталонными результатами.

Property-based (Hypothesis) при необходимости для сложных трансформаций.

9.3. CI:

9.3.1. В CI обязательны:

запуск тестов;

проверка покрытия;

запуск линтеров/форматтеров;

mypy.

9.3.2. Падение любого из этих шагов должно блокировать merge.